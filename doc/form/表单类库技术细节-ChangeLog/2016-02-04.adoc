= Form 改进（2016-02-04）
:toc:


== 精简 Form 和 Field 的接口

* Field 不再支持 group 参数，必须使用 groups 参数。
* Form 关于添加 / 移除 field 不再提供那么多 method，只分别提供一个
* Field 不再支持 setValid 操作。如果以后真的有相关的需要，通过 Form 的 submit 来进行相关支持


== 开放限制

异步验证也可以修改字段值 +
但这有可能带来糟糕的用户体验，即：在用户输入完成很长一段时间后，字段值可能会突然变化。而用户未必能发现这一变化。即使他发现了，也只会感到莫名其妙、无法理解。 +
所以如果要让异步验证修改字段值，在验证完成前，应该在页面上添加提示信息，例如在文本框旁显示正在验证。

异步验证总是可以取消的 +
如果不希望验证被取消，应锁定文本框，避免用户在验证完成前再次修改字段值。 还应锁定提交按钮，因为提交时也会将其取消。

Form 不再关注 onSubmit 回调返回的是不是 cancellable promise，也不再以此判断 submit 事件是否允许取消。 +
如果不希望 onSubmit 被 cancel，应由使用者自己锁定输入控件和提交按钮


== validator 取消 custom rule / 异步验证，新增  功能来代替

=== 1.
validator 不再支持 custom rule。也因此不再有异步的问题，所有 rule 都是同步的。它的定位变成单纯的格式验证。

然后向Field 额外传入一个 bizRule 属性，它的作用是验证字段值是否符合业务逻辑。 +
同之前的 custom rule 不同，即使 field value 经过 validator 格式化后的值为空，也会调用 bizRule。（因此对于 emptyable 的字段，要求 bizRule 能够处理空值） +
bizRule 既可以是异步的，也可以是同步的。甚至可以有时异步有时同步。 +
当它需要异步运行时，就返回一个 promise（验证过程中，如果字段值再次被修改，上一次的验证会被取消，然后重新运行验证；在提交表单时，也会出现 cancel 行为。因此这里的 promise 必须是 cancellable 的。）； +
当它同步运行时，则直接返回验证结果。 +
无论它同步还是异步运行，都可以修改字段值，详见后面的相关说明。 +
bizRule 的返回值格式与 validator 相同。可以考虑像 validator 调用 rule 那样，传给 bizRule 两个函数 valid 和 invalid，以辅助它对验证结果（如未通过验证时的说明）进行格式化。

提交表单时，会取消所有所有正在运行的异步 bizRule。 +
然后对那些还没进行过验证的字段，先调用 validator 进行验证，然后调用它们的 bizRule。 +
如果 bizRule 直接返回验证结果，则提交行为继续正常运行；如果 bizRule 返回一个 promise，立刻取消它，然后继续进行提交。

如果某个字段的 bizRule 异步检查真的非常重要，使用者可能希望一个字段的异步验证一旦发起就不能被取消。因此在验证期间，不可以修改它的值，甚至不可以提交表单（因为这都会导致异步验证被取消）。 +
那么使用者可以自行检查这个字段的状态，当它处在验证中的状态时，将其锁定，以避免用户继续编辑；并提交按钮设为 disable，以禁止表单提交。 +
例如对于一个上传文件的表单，使用者就很可能希望只在所有字段都完全确认合法的情况下才允许提交。因为上传文件是一个很昂贵的操作，如果不这样设置，可能会出现仅仅因为一个小错误，导致费力半天功夫上传的文件白上传了。 +
（通过以上的方法并不能完全避免异步检查被取消，如果有字段还没有被触发过验证，也就是异步检查还没开始运行，此时用户点击了提交，那么 form 会尝试运行它的 bizRule，并紧接着取消它。让此类字段的检查时机设为一 blur 立刻检查可以在一定程度上 +
避免此问题，但还是不能完全避免。不过这种情况下，bizRule 被取消的几率已经很低了，即使不进一步处理，也不会有大问题，所以就保持在这种程度即可。）

在这样的设计下，因为 validator 总是能够得到完整运行，只有 bizRule 可能被取消，就不用关心在后端那会不会因为参数不符合格式而提交失败、用不用让后端输出参数的错误说明了，因为前端已经对格式进行了验证，只要提交失败，只能是业务逻辑方面的问题。 +
此外，因为 validator 变成了同步的，所以不再需要向 rule 传递 from 参数了；而 bizRule 一般都是一个 rule 归属于一个 field，即使不是，也可以通过一个工厂方法提前记录好当前 rule 归属于哪个 field，所以也不需要 from 参数。因此这个参数可以不用了。 +
之前困扰的一个 validator 被用在两个 form 里且 scopedPath 都相同，导致 async rule 没法确定自己是被哪个 field 调用、还没法正常取消 async rule 的问题也解决了（原本考虑的是给 form 也设置一个名字并添加到 scopedPath 里来解决这个问题，现在也不需要了）。

=== 2.
设置了 initValue 或使用了 defaultValue 的字段在初始化时不会调用 validator，直接处于合法状态；bizRule 也一样，在初始化时它也不会被调用，也不影响字段直接进入合法状态。

=== 3.
在把验证行为拆分成 validator 和 bizRule 两部分后，它们之间的关系是这样的： +
validator 验证格式，bizRule 验证业务逻辑。 +
如果字段值不符合格式，那么它肯定也不符合业务逻辑。因此如果字段值没有通过 validator 的检查，就不会再调用 bizRule 进行检查了。 +
如果一个字段值没有发生变化，那么无论重新调用 validator 多少次，得到的结果一定都是一样的；但是，即使字段值没有变化，重新调用 bizRule 也可能导致不一样的结果，因为对业务逻辑的验证结果，涉及到其他字段的值，还可能涉及后端的数据。 +
其他字段的值的变化可能使当前字段的值变得不合法，所以其他字段发生更新时，也要对当前字段重新进行验证。 +
这就是 field.groups 属性的作用，它标记了哪些字段之间是会互相影响的， 只要任意一个 field 发生更新，它所有的 group member 都会重新进行验证。 +
不过，因为 groups 是验证业务逻辑用的，所以在重新验证时，其实用不着再调用 validator 了，只运行 bizRule 即可。 +
如果一个 group member 原本就没通过 validator 的检查，那么什么都不用运行，它现在肯定也不是合法的；如果它原本通过了 validator 的检查，那就只运行 bizRule；如果它正处于待验证的状态，那就 validator 和 bizRule 都运行一遍。 +
（在这样的设定下，如果一个字段没有 bizRule，那么给它设置 groups 完全没有意义，可以禁止给这些字段设置 groups）

除了在字段更新后对 group member 进行重新验证，还有一种情况：在字段正在更新、但还没有触发验证的期间，这个被更新的字段的 valid 会被重置为 null，也就是进入待验证状态。 +
此时，因为它的值的变化可能导致 group member 也不再合法，所以各 group member 也应该进入待验证的状态。 +
（之后执行验证时，也像上一节说的那样，group member 如果原本是通过了 validator 验证的，那么就不会重新运行 validator）

在当前的设计下，要完全实现上述的行为是不可能的。因为现在只用一个 valid 属性记录字段是否通过验证。当 valid = null 时，我们不知道它的当前值是不是通过了 validator 的检查、因为其他原因才进入了这个状态；当 valid = false 时，我们不知道它究竟是被 validator 判为不合法的，还是被 bizRule 判为不合法的。 +
要解决这个问题，需要给字段添加一个 validatePassed 属性。valid = false | null | true 的情况下，它都有可能为 true 。每当字段值发生更新时，它就变为 null；每次执行验证后，它就变为 true 或 false。除了这两点，没有其他因素能使它的值发生变化。 +
我们在每次验证时，就可以通过它来决定是否需要调用 validator。 +

此设计实现起来稍微有点麻烦，因此留到以后在做。目前，虽然我们也可以在有条件的情况下减少对 validator 的调用，但这需要比较复杂的条件分析，而且并不完整。 +
validator 调用的成本毕竟也不是很高，与其费力气去搞一个不完整的优化机制、让运行逻辑变得混乱，还不如干脆每次都执行它比较简单。

=== 4.
bizRule 无论是同步还是异步，都支持修改字段值（也就是之前的“异步 rule”不能修改字段值的设定被移除了）。 +
异步修改字段值不见得体验就不好，使用者可以在异步验证执行期间，锁定当前字段，不允许再修改，并在旁边提示：“正在通过后端对此字段进行格式化”。 +
那么就完全没有问题。

之前因为不支持异步修改字段值，所以会在字段通过同步的 validator 检查后立刻把经过格式化的字段值写入字段状态，而不管后面的异步检查是否能够通过。 +
虽然现在支持异步修改字段值了，但是仍有必要维持原来的设计，即在 bizRule 异步检查完成前，先把经过 validator 格式化的值写入字段（如果 bizRule 是同步的，那就等 bizRule 运行完了之后再写入字段）。 +
一方面这样设计符合逻辑，即只要字段值已经符合格式了，就可以把经过格式化的值变成字段值，而不用管它是否符合业务逻辑。 +
另一方面这也是为了适应 form 提交时的处理方式。form 提交时会把 bizRule 检查都取消，如果不先把 validator 的格式化结果作为字段值，那么此时字段值就会是用户输入的原始值， +
而这个原始值有可能不符合后端的要求（例如 number field 的值没有被转换成数字），导致提交失败。

此外，关于文档中说的，如果支持异步修改字段值，就要支持在提交表单时，后端返回修改后的值，这样不好操作。这个也是可以解决的。 +
首先，需要异步修改字段值的值有两种情况：

. 必须预先异步修改好，才能提交表单，不然提交上去会报错。
  对于这种情况，只要在这个字段完成验证前，不允许表单提交就行了。
. 不预先修改好也没关系，后端会自动修改。
  这种情况下，通过异步验证来修改只是一种优化界面显示出来的内容的辅助行为罢了，其实都压根没有必要。
  也就是说，就让字段值一直保持在没经过异步修改的状态也完全没问题，不影响应用运行。
  而且，让后端在提交后返回格式化的值在一些情况下也是很容易的。如果这是编辑类操作，那么只要让后端在提交完成后，把编辑完成后的值给返回来就行了。
  用这个返回来的值重新填充表单即可。

如果一个 bizRule 是异步运行的，那么在它运行完成前，会先把当前得到的字段值写到字段状态里。 +
参见 Form 文档中所说的：只要确认字段值符合格式，就可以把格式化后的值写入字段状态 —— 即使它不符合业务逻辑。


== 字段通过验证的情况下，也可以设置 message

也就是说字段在 valid = true / false 的状态下都可以有 message。 +
valid=false 状态下的 message 是 error messge，一般显示为红色。 +
valid=true 状态下的 message 是 notice message。也就是说，虽然通过了验证，但此字段值也是有潜在的问题的。可以显示为黄色。

valid=true 状态下设置的 message 和 valid=false 状态下设置的 message 一样，都会在下次进入待验证状态时被清除。

此特性主要是为下面提到的 restoreValid 选项准备。


== 新增 restoreValid 功能
validator 判定字段值不合法时，是否应该保留其当前的不合法值？还是应该返回之前合法时候的值？还是用格式化到当前 rule 得到的值去覆盖当前的不合法值？ +
还是说应该允许手动设置要不要保留不合法值？

例如输入页码的文本框，当发现字段值不合法时，应该立即恢复回正常的页码 +
但对于大部分字段，应该保持当前的错误值，让用户手动去修改

解决办法：

给 field 加一个 restoreValid 选项。若此选项为 true，当发现字段值不合法时，会自动还原到上一次的合法值。 +
在还原合法值时， validator / bizRule 输出的错误信息会得到保留，也就是字段的最终状态是 valid，值是上一次的合法值，但是会把此次输出的错误信息设置成字段的 message（通过上面提到的，在验证结果是 valid 时也能输出 message 信息的特性）。 +
这样设计是为了让用户能察觉到字段值被还原了，以及它为什么被还原。

此选项对 validator 和 bizRule 都有效，也就是说在异步验证未通过的情况下也支持还原字段值。 +
此行为也相当于异步修改字段值，因此在验证进行过程中，也应在字段旁显示一个提示信息。 +

在发现字段值不合法时，如果并不存在上一个合法值，那么此选项不会起作用，字段仍会像普通字段一样，保留错误值，并显示错误信息。（todo: 此行为有没有问题？） +
因此，使用此选项时一般会给字段设置 initValue 或 defaultValue，使其在初始化时直接进入合法状态（设置 emptyable 为 true 并没有此效果，因为设置它之后，字段在初始化时仍会进入“待验证”而不是“合法”状态）。 +
如果不这样做，那么如果用户第一次编辑字段便输入了不合法的值，就只能等之后用户修正成合法值，此选项才能开始发挥作用了。
