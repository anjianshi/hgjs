= 表单类库技术细节
:toc:


== 概述

=== 基本理念
link:表单规范.adoc[表单规范]

表单类库自身在技术上遵循的理念：

 不要限制，要自由。或者说不要因为某个功能在某个情况下不能完全发挥作用，就禁止用户这样使用（这里的限制，是限制用户可以使用哪些功能）。
 让功能优雅降级，把选择权交给用户。
 他希望以这样的方式使用，那么他就要知道在这样的情况下在功能上会有什么限制，哪些功能可能不会生效（这里的限制，是有哪些功能受限于当前的情况而无法运行）。
 然后由他自己决定要不要以这样的方式使用。
 如果他决定要这样使用，那么他就要自己负责处理对应的限制。

=== 表单类库的作用
填写表单，是用户与我们进行交流的过程。这个过程中有三样不可或缺的东西：

Widget::
是我们与用户交流的手段或者说交流管道，它决定了用户可以通过什么方式向我们提供信息（文本框、多选框...）、我们又能通过什么方式向用户反馈信息（tooltip、div）。

Behavior::
是整个交流过程中的“大脑”。负责记录、分析（验证）、处理（例如提交）用户提交上来的信息，并决定要向用户输出哪些信息。

Message::
是我们事先准备好的信息库。程序不是人脑，它只能把预先准备好的信息输出给用户。Behavior 从这里提取出要输出给用户的信息内容。

表单类库主要用来完成 Behavior 的部分。 +
它包含了通用的 Behavior 逻辑，这样制作表单时，只要引入它就可以把大部分的业务逻辑处理好，不用每次都重新写逻辑代码了，同时还能保证提供最佳实践。

对于其他几部分：

Widget::
应用所在的平台（Web、Android、iOS）能够提供一些控件，通过使用控件类库也能引入一些。使用者也可根据需要自行定义。 +
表单类库定义了一套规范且易于兼容的接口，来和来自各种不同地方、遵守各自不同的规范的 widget 进行交互。
如果某个 widget 自身的接口和表单类库的接口不兼容，则需要使用者构建一个 wrapper 来适配。

Message::
表单类库本身提供一些常用的信息。使用者也可自行生成定制化的信息。


=== 表单类库的运行模式
表单类库会根据使用者传进来的表单定位，为 form 和每个 field 生成事件回调，并记录下 form 和各 field 的 state。 +
使用者把类库提供的事件回调和当前的 state 信息传递给各个 widget。 +
这样表单类库就能对用户与 widget 的交互行为进行响应、以及更新 state。 +
widget 则根据当前的 state，决定自身的行为和样式。

''''


== Form 的构成

[source,yaml]
....

CPromise:   Cancellable Promise

---------------------------------

FormDefinition
    fields: FieldConfig[]
                            表单中的字段列表
    onChange                表单中任意字段的值发生更新时便触发此回调（此时各字段的值不一定合法），调用此回调时不会传入任何参数。
                            如果想要监视具体某个字段的值的变化，不应使用此回调，而应专门给那个字段的 widget 设置 onChange 回调（包裹表单类库提供的 onChange 回调）
    onSubmit: (values, prevValues) => SubmitResult | CPromise[SubmitResult]
                            表单提交时，会调用此回调，并把表单中各字段的值传给它
    submitWhenValid: bool   若为 ture，则每当表单进入合法状态时，就触发一次 submit

SubmitResult: undefined | [FieldPath, ValidateResult][]

FieldPath:  string[]


FieldConfig
    default: mixed
    validator: Validator    验证字段的当前值是否符合格式要求，并进行格式化。
    bizRule: BizRuleValidateArgs => ValidateResult | CPromise[ValidateResult]
                            验证字段的当前值是否符合业务逻辑要求，可以是同步的（返回 ValidateResult）也可以异步的（返回 CPromise）。
    validateDelay: int      更新字段值后，等待多久再触发验证。
                            可以是 0（立即验证）、n（若干毫秒后验证）、-1（等待无限长，实际效果就是只有等到 onBlur 或表单提交时才会触发验证）
    restoreValid: bool      当字段值被判定为不合法时，是否要还原回上一次的合法值
    depends: [FieldPath|string][]
                            标记此 Field 依赖于哪些其他 Field。当依赖的 Field 的值更新时，此 Field 也会再次进行验证。
                            指定 FieldPath，代表此字段依赖于那个字段；
                            指定 string，则是方便两个或多个字段之间设置互相依赖。这个 string 相当于一个 nodeName，多个字段都在 depends 列表里加上这个 nodeName，就表示它们都挂载在同一个节点上了。
                            只要节点中任意一个字段的值更新了，其他字段就会触发一次验证。

BizRuleValidateArgs: (value, valid, invalid, formState)
                            调用 valid 和 invalid 来生成验证结果并返回，这样就不用自己构建 ValidateResult 对象了。
    valid(formattedValue): ValidateResult
    invalid(message): ValidateResult

ValidateResult: {valid: true, value: mixed} | {valid: false, message: string}

---------------------------------

FormState
    status: valid | invalid | toBeConfirm
                            表单下所有字段的状态
                            valid： 所有字段都合法    invalid：有字段不合法    toBeConfirm：有个别字段尚未验证或正在验证中，其他字段均合法
    submitting: bool        表单是否正在提交
    fields: FieldState[]


FieldState
    latestValidValue: mixed
                            字段最近一次的合法值。如果当前是 valid 状态，那么这个就是当前值。
                            此值是经过 validateor / bizRule 格式化过的值，它的类型就是业务逻辑上应有的类型。
    propsValue: string      字段当前的“控件值”，也就是 widget 里当前实际呈现的内容。
                            可以是字符串，也可以是其他值。不过为了适应 react 的 input widget 的 value 不能为 null 的要求，当值为 null 时，会强制转换为字符串。
                            这个值无所谓合法不合法，它就相当于是一个 buffer。
    hasFocus: bool          字段当前是否拥有焦点
    status: valid | invalid | validating | toBeValid
    message: string         字段的错误信息，只在 status=invalid 时有值

---------------------------------

Validator
    constructor(specs)      参数 specs 是对字段的格式要求，例如要求字段不能为空（也就是必填）、或是长度不能大于10。
                            不同类型的 validator 支持不同的 specs
    validate((...ValidateArgs)): ValidateResult
                            调用此方法对字段值进行验证、格式化

---------------------------------

InputWidget
    constructor(value: mixed, callbacks: WidgetCallbacks)

WidgetCallbacks
    onFocus                 可选支持
    onChange(value)
    onInput(event)          可选支持
    onBlur                  可选支持
....

''''


== 验证用户输入

=== 字段的验证状态
一个字段在验证方面，有如下几种状态：

待验证:: 这个字段还没有被验证过，不知道它的值是否合法。例如：表单刚载入进来、或是字段值已更新过，但还没触发验证
验证中:: 验证操作有可能是同步完成的，也可能是异步完成的。若是异步进行，则在完成前，字段会处于“验证中”的状态
不合法:: 字段值没能通过验证
合法:: 字段值通过了验证

表单刚载入时，填充了初始值（initValue）或者使用了默认值的字段进入“合法”状态，其他字段都处于“待验证”的状态。 +
就是说，表单初始化时，不会对字段进行验证，只有用户与一个字段交互过之后才会开始对它进行验证。 +
这样设计可以避免给用户带来困扰：如果表单刚一打开，用户还什么都没做，就冒出一堆错误提示，会让人感到反感。

PS. +
把填充了初始值或默认值的字段直接设定成“合法”状态是有意义的。 +
有些表单是只要表单进入了合法状态，就会触发提交行为。 +
如果设置了初始值或默认值的字段默认不是处于合法状态，例如处于待验证的状态，那么用户必须得挨个碰一下这些字段，才有可能触发表单的提交行为。


=== 如何执行验证
验证字段值时，会依次用 validator 和 bizRule 对它进行检查并生成经过格式化的值：

* validator 包含了通用、标准化的验证规则，用来验证字段值的格式，例如字符串长短、数字大小。
* bizRule 则是自定义的代码，主要用来进行业务逻辑方面的检查，也可以用来补充 validator 没有提供的验证规则。

在字段没能通过验证时，bizRule 或 validator 必须返回一个 message，好让用户知道是哪里有问题 +
若一个字段没能通过 validator 的检查，将不再对它执行 bizRule 检查。

==== bizRule
bizRule 可以同步执行，也可以异步执行（甚至同一个 bizRule 可以有时同步有时异步执行），以便实现调用后端 API 来完成验证。 +
同步执行时，直接返回验证结果；异步执行时，返回一个 CPromise，最终解析出验证结果。

异步 bizRule 在运行完成前，字段会处于”验证中“状态。 +
如果在异步验证完成前，用户再次更新了字段值，或是触发了表单提交，则此次验证会被取消（利用 CPromise 的 cancel 功能）。

在异步 bizRule 中修改字段值时要注意，这样做在用户看来的效果就是“在输入完内容好几秒后，字段里的内容突然自己变化了”，容易让人困惑。 +
可以考虑在验证完成前，在字段旁显示一个“验证中...”之类的提示。

==== restoreValid
restoreValid 会在字段没能通过 validator 或 bizRule 验证时，将其还原回之前的合法状态（具体时机见稍后提到的“restoreValid 的执行时机”）。 +
例如输入页码的文本框，当发现字段值不合法时，应自动恢复回正常的页码。

此选项对 validator 和 bizRule 都有效，也就是说在异步验证未通过的情况下也支持还原字段值。 +
不过这种情况下也相当于异步修改字段值，因此也要注意对用户是否友好。

===== restoreValid 的局限
restoreValid 并不能保证一定把值还原回合法的状态。

. 如果不存在“上一次的合法值”，那么压根就没法进行还原。这时就会像未设置 restoreValid 时那样以未通过的状态结束验证。 +
  因此，使用此选项时，一般会给字段设置 initValue 或 default，使其在初始化时直接进入合法状态（设置 emptyable 为 true 并没有此效果，因为设置它之后，字段在初始化时仍会进入“待验证”而不是“合法”状态）。

. 因 depends 关系（而不是这个字段本身的值更新了）触发的验证，没法恢复合法值（depends 关系将在后面讲解） +
  一个字段，它的值 A 原本是合法的，现在另一个字段更新了值导致它的值不合法了，这时怎么进行 restoreValid？上哪去找那个 valid 的值？这种情况下，只好把 field 变为 invalid。 +
  因此，对于有 depends 关系的字段，若要使用 restoreValid，一定要清楚可能发生哪些的情况（并不是不能使用，只是要慎用）。

. 即使在代码层面成功进行了还原，也并不能保证还原回来的值真的就是合法的，例如不能保证提交到后端后，一定能通过验证。 +
  因为字段中记录的 latestValidValue 本身就不能保证一定是合法的。 +
  例如用户名字段，原本字段值 ABC 是合法的，现在输入了一个不合法的值，触发了 restoreValid，想要还原回原来的 ABC，但其实在这期间，已经有其他用户使用了这个名称，导致 ABC 其实已经不合法了。 +
  不过这其实没关系，在前端，我们永远不可能 100% 确定一个涉及业务逻辑检查的字段是合法的，所以我们就视其是合法的，待之后提交时，由后端来进行检查。


=== 如何更新字段值
格式化字段值的意义在于去除多余的部分，调整数据的类型（string、bool、number、date...），以便于在程序中使用； +
同时，把用户输入到 widget 里的内容经过修整后再重新显示回 widget 上，可以便于用户进一步输入、编辑，看起来也更美观、清晰。

但有几点需要注意：

. 对 widget 里显示内容的修正不能打扰用户的输入行为。 +
  例如用户想要输入 0.01，如果在输入到 0.0 时刚好触发了验证，那么值会被转换成 0。这时如果把转换过的值 "0" 填充到 widget 上，将会干扰用户输入，使得他没办法把后面的 1 输入上去。

. 当用户的输入不符合要求时，不要尝试对其进行格式化，这样并不会帮到用户；而是应该原样保留用户的输入内容，给用户一个机会，让他自己在不合法的值的基础上把它改合法

此外，react 要求传给 input widget 的值必须是字符串，因此我们并不能把格式化、转换过类型的值传给 widget，而要单独维护一个字符串格式的字段值。

基于以上几点，字段值被设计成分别存放在两个属性里：latestValidValue 和 propsValue。

* propsValue 是传给 widget 的部分，它代表文本框中当前显示出来的、未经处理的内容。
* latestValidValue 是最近一次验证通过了的合法值，用来在程序里使用，实现 restoreValid 时也必须依赖于它。 +
  这个值并不能代表字段最新的状态，通常仅当字段的 status=valid 时使用它。

为了不打扰用户输入，在 widget 没有失去焦点前，无论发生什么，程序都不会对 propsValue 进行修改。它会一直保持用户输入的状态。 +
当 widget 失去焦点时，如果字段当前处于合法状态，将会根据 latestValidValue 重新生成一个格式化过的 propsValue。 +
（如果是在 widget 没有获得焦点的情况下进行的验证，例如是因 onBlur 或提交表单触发的验证，则没有这些问题，直接对 propsValue 进行更新）

==== restoreValid 的执行时机
就像修改 propsValue 那样，restoreValid 只会在字段 onBlur 时执行（执行后顺便格式化 propsValue）。 +
因此，在 onBlur 之前，如果字段值验证失败，它将暂时保留在 invalid 状态，直到 onBlur 时才还原回合法值和合法状态。 +
这样，用户在输入过程中，如果字段值不合法，他就有机会看到字段的错误信息， 然后主动去改正。 +
如果不这样做，而是每当验证不通过时就立刻进行修正，那么用户在输入过程中就无法得知自己的输入内容已经出错了，然后输入完毕 onBlur 时，会发现字段值突然还原了回去（甚至可能没发现字段值已经还原了），非常突兀。


=== 进行验证的时机
在用户与字段控件的交互过程中，应该在哪个时机对字段进行验证呢？ +
有如下几种方案：

. 字段值每发生一次变更（例如在文本框中输入了一个字、在 select 控件中选中了一个 options、选中了 checkbox / radio）就触发一次验证
. 字段值变更过了若干毫秒后，进行验证。若在时限到达前先发生了 onBlur，忽略时限，立刻进行验证
. 字段值变更后，直到 onBlur 时才进行验证

另外，还有一种隐式的验证时机：提交表单的时候。 +
如果一个字段从表单初始化后一直没有进行过交互，就会在这时触发验证。（参见后面的“验证与提交”）

对时机的选择会影响到以下几方面：

. 用户看到错误信息的时机。是边输入边看到还是离开字段后才看到。（大部分情况下应该是边输入边看到）
. 触发提交行为的时机。 +
  有些表单设置了 submitWhenValid，每当表单中所有字段都验证通过，就触发一次提交。 +
  因此， 验证的时机决定了是允许边输入边触发提交，还是等离开字段后才触发提交。 +
  （大部分情况下应该选择边输入边触发提交，无论当前是查询类表单还是编辑类表单。因为要想触发 onBlur，要特意向文本框外点一下，好让文本框失去焦点。但大部分用户意识不到这样的操作，即使能意识到，也不习惯）

在表单类库中，可以通过 valiateDelay 来控制字段的验证时机。 +
valiateDelay 从字面意思理解，是“字段内容更新后，等待多长时间便触发验证”的意思。

* validateDelay=0，代表不等待，也就是值一变更，就立即进行更新
* validateDelay=n，是等待 n 毫秒
* validateDelay=-1，则是无限长的等待时间

无论将 valiateDelay 设成什么值，只要字段在 onBlur 时处于待验证状态，就会立刻触发一次验证。 +
因此上面无限长的等待时间，实际的效果就是在 onBlur 或触发表单提交时进行验证。

此外，用户在文本框内按回车，也视为发生了 onBlur 事件（虽然并没有真的 blur），立刻触发一次验证。

例如对于 <select>、单选框、多选框等不是输入内容而是通过点击直接修改内容的 widget，以及那些每次调用 onChange，提供的都是经过验证 / 格式化后的值的自定义 widget，应将 validateDelay 设为 0； +
对于一般的文本框类字段，根据需要设置合适的延迟； +
除少数有特殊需求（例如为了配合交互模式）的字段外，大多数字段不应该将 validateDelay 设为 -1。

==== 字段间的依赖关系与关联验证
有时，一个字段的值是否合法，要根据其他字段的值来判断。因此那个的字段更新了的时候，当前字段也要重新进行验证。 +
这种字段 B 更新时，字段 A 需要重新验证的情况，称之为“A 依赖于 B”。

例如一个表单中有两个字段：最大数值和当前数值，“当前数值”的字段值不能大于“最大数值”的字段值。 +
当我们减小“最大数值”时，“当前数值”会变得不合法。我们就可以说“当前数值”字段依赖于“最大数值”字段。

有时 ，两个字段还有可能互相依赖。 +
例如有两个填数值的字段 A 和 B，要求它们之间的和是 10。 +
现在两个数值都是 5，所以都是合法的。如果我们把 A 改成 6，A 和 B 就都会变得不合法；接下来再把 B 改成 4，它们就又都合法了。

在表单类库中，通过 depends 来指定一个字段依赖于哪些字段。

===== 不使用 depends 的技巧
depends 虽然很方便，但也不应滥用。有些问题其实可以不使用它，更简单地解决。 +
例如名称互换的情况：有两个字段 A、B，它们的值不能相同。现在 A=1, B=2，用户想把它们改成 A=2, B=1。 +
如果使用 depends，这个就是典型的互相依赖。先把 A 的值改成 2，导致 A 和 B 都变得不合法，再把 B 改成 1，再次触发验证，A 和 B 就都合法了。

这样做的问题是，在把更新结果提交到后端时，后端要想保存这些变更，也必须对这种冲突的情况进行处理。 +
它要先把 A 改成一个完全不同的其他值，例如 999，然后将 B 改成 1，回过头再将 A 改成 2。

一个简单的解决办法是在前端不用 depends，而是利用 restoreValid 来完成对它们的验证。 +
也就是压根不允许出现 A 和 B 名称相同的情况 。当 A 的值被设成 2 时，它会被还原回之前的值：1。 +
这就要求用户自己想办法，将 A 先设成其他的什么值，然后再接着修改。也就是把原本由后端来完成的操作改为由用户来进行。

这样做对用户来说，有可能比使用 depends 麻烦一点，不过也有可能反而比使用 depends 效果要好。用户可能反而更容易掌握、判断程序的运行规律。

===== depends 与对 validator 和 bizRule 的调用
因 depends 关系而重新验证字段时，需要验证的是“业务逻辑”。因此如果目标字段已经原本已经通过了 validator 的验证，这里就没必要再执行一次了，只执行 bizRule 就好。 +
具体来说，如果当前字段是合法状态，那么只执行 bizRule； +
如果是待验证状态，则和平常验证时一样，调用 validator 和 bizRule； +
如果是验证中状态，取消当前正在进行的 bizRule 验证，重新运行一次。

===== depends 与连带验证
如果 A depends B，B depends C，那么当 C 变更并导致 B 重新验证时，A 是否也跟着重新验证？

在现在的实现中，只有直接依赖与 C 的字段会触发验证。也就是说 A 不会被验证。 +
这样设计是因为在目前能想到的环境里，并没有发现有这么深入的连带关系，需要进行这种类型的连带验证。


=== 验证与提交
只要没有字段明确处于“不合法”的状态，就允许提交表单。 +
通过设置 submitWhenValid，还可以只要表单一进入合法状态，就触发一次提交。

在提交时， 如果有字段处于“待验证”或“验证中”的状态，会进行如下处理：

. 对所有待验证的字段进行验证（PS1、PS2） +
  只要有任意一个字段验证失败，便终止提交。（但不会终止此次验证行为，无论如何都会把所有待验证的字段都验证一遍。这样用户就能一次性看到所有不合法的字段了。 +
  不然他修正好了一个，点击提交，发现又出来一个不合法的字段，就太烦人了） +
  验证过程中，有的字段通过了同步验证后可能还会引出异步验证。虽然接下来表单很可能马上就要提交了，一旦提交，这个异步验证就没有用且要被取消了，但这里还是先留下它，让它运行着。 +
  万一对下一个字段进行同步验证时发现那个字段通不过验证、整个提交进程终止了，这个异步验证就可以继续照常运行了。

. 如果所有字段都通过了同步验证，接下来取消所有正在执行的异步验证（包括原本就在运行着的和上一步里触发的）。 +
  首先，我们不可能等所有的异步验证都通过了才来提交表单，那太慢了。 +
  其次，我们可以把原本需要异步验证来进行的检查在这次表单提交中一并完成。 +
  因为后端在处理提交上来的表单时，一定还要再验证一次。之前交由异步验证执行的那些检查，后端也一定都会检查一遍。所以不用再等异步验证来返回检查结果了。 +
  直接由后端经过检查，如果没问题，就执行操作；如果有问题，就返回错误信息，然后前端经过处理，把格式化过的错误信息交给 Form，Form 再来根据这个信息修改各个 field 的 status 和 message。 +
  上面所有取消了异步验证的字段，在取消后，处于 status = valid 即验证通过的状态（PS3）。

. 表单的提交可以异步，也可以同步完成。 +
  若要异步完成，则返回一个 Promise；若同步完成，则直接返回提交结果。 +
  同步形式的提交适用于不需要调用远程 API，或是远程 API 的执行结果不影响提交结果的提交行为。 +
  设置了 submitOnValid=true 的表单，很多都是这种类型的。虽然 submit 回调中也会执行 API  调用，但这个调用的结果并不会影响 form 的状态。

. 提交完成后，使用者可以将后端对部分字段的验证结果返回给前端（如果有的话）。 +
  这些结果可以是验证通过，也可以是未通过，也可以有的通过有的未通过。（PS4） +
  表单会根据它们，设置各字段的状态和值。 +
  标单类库并不关注表单是否提交成功了，它只关注是不是有字段的状态需要更新。 +
  因为无论提交成功与否，对它的运行都没有任何影响，也不会改变它的 state。

//

PS1:: 异步验证中的字段均是已经通过了同步验证的，因此不用再验证一次了。

PS2::
这里的“待验证字段”主要是那些自表单载入以来就没有被编辑过的字段。因为没有编辑过，所以一直没有触发验证。 +
那难道没有其他待验证的字段的了吗？ +
事实上确实是没有的。因为如果一个字段曾经编辑过， 它一定符合下面两条的其中之一：

. 它已经 onBlur 了，那么在 onBlur 时会立刻触发验证
. 它当前正拥有光标。那么当前一定是通过在这个文本框内按了回车而触发了提交（因为如果是按提交按钮，在按到按钮前，会先触发这个字段的 onBlur 事件）。 +
  但是按回车时和 onBlur 一样，也会立刻进行验证，所以在开始提交时，这个字段也是经过验证了的。

PS3::
把取消了验证的字段设置为 status=valid 而不是 status=toBeValid 即待验证状态的意义在于，用户下次提交表单时，就不用再对它们进行重复验证了，因为它们之前已经经过了验证。 +
如果它们被设为 stats = toBeValid，则在下次提交时，要再次对它们执行同步验证，进而触发异步验证，然后可能很快异步验证又再次被取消。 +
设为 status = valid 的一个小缺点是，用户点击这个字段，没有进行输入，然后就离开了的话，因为它处于合法状态，在 onBlur 时并不会触发验证，也就错失了一个可以把被取消的异步验证给弥补回来的时机。 +
如果设为 status = toBeValid 则没有这个问题。但是因为这种情况出现的几率很小：用户要不不点字段，要么点完了大部分情况下都会输点什么， 所以也无所谓了。

PS4::
若这里返回了一些字段验证未通过的信息，并不代表其他字段就一定是合法的。 +
因为后端的验证有局限，只要发现任何一点问题，就会停止一切验证并输出结果。 所以后面那些字段可能只是压根没被验证到，而不是确定合法了。

==== 取消提交
在提交完成前，如果表单发生了更新，例如修改了某些字段的值、修改了添加、移除了字段...，那么此次提交会被取消，所有字段保留当前的状态。 +
若使用者不希望这种事情发生，应在提交开始后注意避免。例如禁用表单中的各字段和提交按钮。


=== 第三方 widget 与验证
部分第三方 widget 可能并不能完整支持表单组件的 widget 规范。 +
例如不支持 onFocus 和 onBlur，对 value 的格式要求不标准（不支持字符串 value，需要传递指定类型的 value），不支持 onChange 回调或对 onChange 的处理和普通的 widget 不一样。 +
对于这些情况，要由使用者自行想办法去适配。

下面是一些常见的问题：

. onFocus 和 onBlur 应该要么同时支持，要么同时不支持，不然会给程序处理带来混乱
. 不支持 onFocus / onBlur 的 widget，就会被视为一直处于 blur 状态，因此每当进行验证、对值进行格式化时，最新的值都会立刻同步过去。
. onInput 用来监听敲击回车的事件。因此不支持此事件的 widget 无法通过按回车来触发验证

''''


== 字段值的处理规范

=== 空值与默认值

==== 前后端在“空值”与“默认值”方面的交接
前端除了要考虑自己如何验证表单外，还要考虑如何与后端交接。这种交接主要就是针对字段的“空值”与“默认值”。

后端验证表单时，一个字段可能有3种状态：

. 没出现。它根本就没在提交上来的表单中出现（例如前端在提交表单时，把没有值的字段过滤掉了）。
. 空值。也就是空字符串，如果是以 JSON 形式提交上来的表单，也有可能是 null。
. 有值。

后端处理字段的“空值”时需要考虑这样一件事情：

. 空值从逻辑上可以代表一个字段没有被赋值。（如果此字段有默认值，那么此时应该填充默认值）
. 也有可能是用户有意要把这个字段的值设为空。

如果后端同时认同这两条，那么对于一个既有默认值，又允许空值的字段，在这种状况下它是没法处理的。 +
是视为没有赋值而填充默认值，还是让这个值留空？
为了避免这个困境，只好放弃对其中一条的支持：

* 把空值就只视为是空值，同时为了支持填充默认值，把字段不出现视为希望填充默认值。
* 或是反过来，把字段为空视为填充默认值，把字段不出现视为填充空值。

对比起来，自然是第一种方式比较符合直觉，更合理一些。

这种放弃其中一条的行为其实就是要求前端指明一个字段到底是要用默认值还是空值。让前端去判断该不该把一个字段包括在表单里，或是以空值提交。 +
在这背后，可以引申出这样一条规律：

 如果一个字段既有默认值又支持为空，那么必须由整个数据传递链条的最前端主动声明是希望使用默认值还是空值。

因为最前端不指明的话，后面的节点自然是猜不出来的。 +
那么这个数据链条的最前端是前端界面吗？不是，是用户。所以其实前端也不知道应该使用默认值还是空值，它必须想办法让用户来选择 / 声明。 +
办法有两种：

. 在每一个有默认值的字段处添加一个勾选框，让用户选择是否使用默认值。这样子前端就能确定用户是想要指定空值还是默认值了， +
而且前端自己并不需要知道默认值是什么只要让后端填充就好。
. 前端自己填充默认值，提交给后端的表单是已经填充好的，也就是压根用不着把字段留空让后端来填充了。

第一种设计既不直观（用户看不到那些决定使用默认值的字段最终的填充结果），又使界面变得复杂。所以虽然第二种没能充分利用上后端的资源，有点重复劳动的意思，但一般还是使用第二种设计。

就像是一个咖啡店，点咖啡时可以选择加糖（默认值）、加奶油或什么都不加（空值）。 +
那么必须让客人自己表达出他是希望用默认的加糖，还是什么都不加，或是其他什么。如果客户自己不说，后面倒咖啡的人自然不可能知道客户想要什么，即使是直接和客人打交道的服务员也不可能知道。

此外，关于前端第二种设计的重复劳动的问题，可以干脆把填充默认值的工作全部交给前端，后端根本不支持填充默认值（也就是不支持在提交表单时，不把某个字段包括在表单里），那么就没有重复劳动的问题了。 +
不过要注意，如果后端除了能被前端 Web 界面调用，也有可能被以编程的形式调用，甚至是后端 API 内部互相调用，那么就不能这么设计，必须让后端也支持填充默认值。 +
因为编程调用和 API 内部调用时，调用者压根不知道默认值是什么，必须由后端自己填充。

==== 空值与“必填”
在后端，表单字段有一种概念叫 required。它的意思是这个字段必须有值（空值也算有值，required 不负责检查空值，而是由另一项概念 nullable 来控制一个字段是否能为空）。 +
拿上一段提到的字段的三种状态来说，就是不能“不出现” —— 除非这个字段有默认值（也就是说，只要一个字段有了默认值，required 限制就没有意义了，因为它无论如何都是有值的嘛）。

不过对于前端来说，一个字段是不可能“不出现”的，因为它就明明白白的以 HTML 元素的形式定义在表单里。 +
（本质上来说，是因为字段都是被前端自己以 HTML 元素的形式定义在表单里的，而不是另一个人以数据的形式传给它的） +
因此，required 检查在技术上其实是不需要的。 +
前端需要的，是“是否为空”，也就是 nullable 的检查。 +
不过为了让用户便于理解，有时候还是会使用“必填”等字样，这也无可厚非。 +
但在开发的时候，一定不要被这个词迷惑了，写给用户的“必填”实际的意思是“不能为空”。 +
例如如果一个字段有默认值，那么用户不用填，它也仍然不违反“必填”的检查规则；但如果用户把它的值清空了，那么将违反“不能为空”的规则。

==== 空值与空字符串
前端字段值处理的另一个问题是如何区分空值与空字符串。 +
这个问题只在前端通过 JSON 提交表单数据时会出现：对于没有填写内容的字段，是把它提交为 null 还是空字符串呢？ +
想要通过某些技巧，例如根据用户是如何使字段内容变空的，来选择提交 null 还是空字符串基本是不可能的。 +
那么就只能是一律提交 null，或是一律提交空字符串。 +
因此这其实是一个前后端的约定的问题。只要做好了约定，并根据这个约定进行后续处理就好了。 +
个人觉得用 null 更好一些。这涉及到非字符串类型的字段，例如数字字段。 +
这些字段在没有值的情况下，显然是用 null 来代表比用空字符串来代表显得更合理一些。 +
那么字符类的字段在没有值时也跟着用 null 来代表，可以和其他字段更统一一些，在处理的时候就不用分别处理了。 +

''''


== 处理复杂表单

实际应用中，表单并不是固定地由几个字段组成这么简单的。 +
我们会遇到：

重复型的字段::
也就是多个字段表达的是同一样东西。 +
例如一个表单中让你填写最爱吃的五样食物，与这五样食物对应的字段不像“用户名”和“密码”那样有独立的自我定位，它们都表达了同一样东西，只能是分别给予一个编号：食物1、食物2...

会动态添加、删除的字段::
根据用户在表单中输入的内容，字段有可能会动态添加、删除。 +
还是上面的填写最喜欢的食物，有可能设计成一开始给出5个字段，但当用户填满5个时，会自动增加字段以让用户可以填写更多； +
而如果用户把某个字段的值清空了，则视为他不再认为这是自己喜欢的食物，把这个字段删除。

十分庞大的表单::
一个表单有可能包含非常多的字段，怎么有有条理地维护他们，怎么区分哪个字段是归属于哪个部分的，也是一个问题。

面对这些情况，首先，我们的表单必须支持字段的动态添加、删除；其次，为了更方便地对字段进行划分，可以给 Form 设计一个 scope 功能，就像编程语言里的 namespace 或 module 那样。

''''


== 其他想法

=== form reset 功能
之前考虑过给 Form 添加 reset 功能。（效果和 input type=reset 一样） +
对于指定了 initValue 的字段，reset 时会恢复到 initValue 而不是 default 的状态。 +
这对编辑型（例如编辑商品）表单会有帮助。

但这个功能有个问题：表单的字段是可以动态添加删除的，在 reset 时，是不是要把动态添加删除了的字段也恢复原样？ +
这很难做到。因此比较好的方法是让使用者自己实现这一功能。在需要 reset 时，干脆移除当前的表单，用最开始的数据重新构建一次。

=== 离开页面提醒
想办法支持：若在字段更新、但还没有验证或提交的情况下试图刷新、离开页面，会弹出一个对话框来确认一下，以避免尚未保存的资料意外丢失。 +
可以在 Form onChange 发生时记录下来，每当要离开页面时通知。然后每次 Form onSubmit 就把记录下来的标志清除。

=== 让 Form 支持设置“元信息”
有时候我们会为了提供一些额外的信息，特意在 form 里加一些字段。 +
例如在编辑商品的表单中，设置一个 id 字段。如果它有值，说明是在编辑商品资料；如果没有值，说明是在创建商品。 +
这类字段本身不会被修改，其实完全没必要作为 field 来处理。 +
因此，Form 应该支持在初始化时定义“元信息”，它们在 Form 的整个周期内都不变。调用 valid / submit 回调，甚至 field 的 bizRule 时，都会把这些元信息传给它。

=== 让 validator 输出错误代码而不是具体的错误信息
考虑让 validator 输出 message 时，只输出错误代码以及发生错误时的 specs 参数（不只是此 rule 的参数，而是整个 spec，让使用者自己决定要读取其中的哪些来生成错误信息），让使用者根据它们自己生成错误信息。 +
这样就能实现根据页面内容生成有针对性的错误信息。例如对于用户名字段，就说：用户名不能超过 10 个字；对于商品名称，就说商品名称不能超过 10 个字。 +
如果使用者希望对于同类字段能统一输出同样的错误信息，而不用每次都重新写一遍，他可以自己构建一个对照表，一种错误代码对应一个错误信息模板。
