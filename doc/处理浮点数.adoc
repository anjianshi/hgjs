= 处理浮点数

对浮点数精度问题的描述，见 link:http://www.pythondoc.com/pythontutorial3/floatingpoint.html[浮点数算法：争议和限制]
对此问题的处理，有两种思路：

. 直接使用 float 类型，但在每次显示时，进行小数位截取。 +
  Python: `format(number, '.2f')` +
  JavaScript: `number.toFixed(2)`

. 在存储、计算时，使用高精度的类型，例如 Decimal （python）、Big.js

. 不使用浮点数，使用整数来处理、存储数据。例如对于金额，可以以”分“或者”厘“而不是”元“作为单位，然后以整数进行存储。 +
  这样的好处是天然的限定了小数位数，而且不用依赖任何类库，且能保证绝对的安全、可控。

下面我们一个一个地分析这几种思路。

== 思路一
在上面给出的文章中提到，对于浮点数的处理，没有简单的答案，但也不要过分小心浮点数。 +
也就是说，对于对精度要求并不高的场景，没有必要特意保证对浮点数的完全控制，只要在输出时，进行一下格式化处理即可。 +
首先，在 Python 端，并不需要在意对小数的显示，即使一个小数已经丢失了精度，在显示的时候，python 也会自动处理成基本正常的情况。 +
例如 0.1 虽然不是真的 0.1，但是在输出、转换成 json 时，都会以 0.1 的形式显示出来。 +
在 JavaScript 端，虽然没有像 Python 这样的自动处理机制，但也有一个非常方便的 .toFixed() 方法，可以输出指定位数的小数。

表面上看，好像问题可以解决了，但实际上，这样的方案并不能保证一定不出问题，尤其是在对数值进行大于、小于、等于比较时。 +
例如某字段的当前值是 0.3，现在把一个通过 0.1 + 0.1 + 0.1 或是 sum([0.1, 0.1, 0.1]) 计算得到的数值与它进行比较，得到的结果将会是”不相等“。

假设有这样一个订单，订了三件不同的商品，每件的价格都是 0.1 元，那么总价应该是 0.3 元，但实际合计出来的总价会是 0.30000.....4 元。 +
接下来，客户付了 0.3 元的款，此时应该判定为款项正确，但是实际比较出来的结果却是付的款项小于商品金额，也就是钱没给够。

因为我们的应用里涉及到钱，且要求对金额的计算和判断必须是正确的，所以这样的解决办法并不能符合我们的需求。


== 思路二
为了保证应用的可靠性，使用不会损失精度的数据类型。
具体的解决方案如下：

* PostgreSQL 中使用 Decimal 类型，不限制小数位数
* Python 中使用 Decimal 类型进行计算和比较，不限制小数位数（需要为 Decimal 设置不允许 decimal 和 float 混合进行操作的 flag）
* JSON （前后端传输）中，使用 string 来表示浮点数，并统一格式化为两位小数（无论是前端提交给后端，还是后端输出给前端）
* JavaScript 中，使用 Big.js 进行计算和比较，不限制小数位数 +
  （为此，前端需要做一个 transformer，把从后端获取到的数据中指定的 key 从 string 转换成 big.js；可能还需要一个改良版的 json stringify，能把 big.js 对象转换成两位小数的 string （big.js 对象可以直接 json 化，只是不支持限定小数位数））

在传输过程中，之所以选择使用 string 格式，而不是 float 格式，是因为无论前端还是后端，在生成高精度数值对象时，通过字符串来生成都是比较保险、直接的方式，完全不用担心精度的丢失。

此方式需要对较多的地方进行配置、处理，比较麻烦，且输出数据时，依然要进行一定的格式化（丢掉多余的小数位数）。但是最灵活，扩展性比较强（例如可以支持任意位数的小数）。


== 思路三
此思路适用于“钱”这类小数位数固定的数据。
基本不需要配置，只是在输出给用户时，需要格式化一下；由用户输入数据时，也要对用户的输入进行一下转换（以”元“为单位转换为以”分“或”厘“为单位）。 +
因为我们的应用基本上只有”钱“会涉及到小数，所以决定使用这一种，而不是第二种思路。这样配置起来比较简单，又省去了对其他类库的依赖。

具体来说：

. 前后端均使用 int 作为表示”金额“的数据格式，以”厘“为单位（因为以后可能碰到单价以“厘”为单位的商品），因此要转换成”元“应该除以 1000。

. 前端实现一个函数 "money(value)"，把以”厘”为单位的数据转换为以“元”为单位，并进行格式化（如在前面加上 “￥”符号、将其填充成两位小数（zero padding））

. 前端实现一个基于 number validator 的 money validator，当 number validator 把用户输入的文本数据转换成 number 后，它再把用户输入的以“元”为单位的数据转换成以“厘”为单位的数据。 +
  如果传给 validator 的已经是 number 了，那说明这是已经转换过的值，直接返回即可。当字段因为 group member 的值发生更新而被触发验证时，会出现此情况。

. 前端还要实现一个 money input 控件，把以“厘”为单位的原始字段值，转换为以“元”为单位的值后，再把它作为 input value。 +
这个控件要注意一件事，当 form field.value 是一个数字时，说明传给它的是 money validator 格式化好的以“厘”为单位的数据，此时它应该进行格式化； +
如果 field.value 是一个字符串，说明这时还没有被格式化，应该原样输出。 +
还应该注意，这里是用 field.value 来判断，不能用 field.valid 来判断。因为 field.valid 为 null 不代表字段值就一定没有被格式化。 +
如果一个 field 有异步 bizRule，那么在 bizRule 运行完成前，field.valid 都是 null，但是 field.value 已经是格式好的以“厘”为单位的数值了。

money input 和 money validator 是对应的关系： +
一个把应用中存在的以“厘”为单位的值转换成以”元“为单位，供用户修改； +
另一个把用户输入的以”元“为单位的值转换成以”厘“为单位，再交给应用去处理。

虽然现在在数值上以“厘”为单位，但显示的时候只保留到两位小数（也就是“分”）

（以上 form / field / validator 等内容来自 Form 类库（src/form））
